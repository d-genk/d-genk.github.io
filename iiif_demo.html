<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IIIF Region Annotation Demo (Rect + SVG + Canvas Picker)</title>
  <style>
    body { background: #23272f; color: #eee; font-family: sans-serif; margin: 0; }
    #loader-bar { background: #20222a; padding: 1em 2em; display: flex; gap: 1em; align-items: center; border-bottom: 1px solid #333; flex-wrap: wrap; }
    #manifest-input { flex: 1 1 380px; min-width: 320px; font-size: 1em; padding: 0.4em 0.7em; border-radius: 4px; border: 1px solid #555; background: #181818; color: #fff; }
    #load-btn, #reload-btn { padding: 0.5em 1.2em; font-size: 1em; border-radius: 4px; border: none; background: #378cff; color: #fff; cursor: pointer; transition: background 0.2s; }
    #load-btn:hover, #reload-btn:hover { background: #2265c7; }
    #canvas-select { min-width: 260px; font-size: 1em; padding: 0.45em 0.7em; border-radius: 4px; border: 1px solid #555; background: #181818; color: #fff; }
    #viewer-container { display: flex; }
    #canvas-holder { position: relative; background: #111; flex: 1 1 auto; height: 85vh; display: flex; justify-content: center; align-items: center; min-width: 400px; }
    #iiif-canvas { box-shadow: 0 0 20px #0008; background: #111; max-width: 98vw; max-height: 84vh; }
    #overlay-svg { position: absolute; left: 0; top: 0; pointer-events: none; }
    .shape { fill: rgba(63,193,255,0.15); stroke: #3fc1ff; stroke-width: 2; pointer-events: auto; cursor: pointer; transition: stroke 0.1s, fill 0.1s; }
    .shape.active { fill: rgba(255,203,107,0.20); stroke: #ffcb6b; }
    #sidebar { width: 350px; background: #1a1c23; border-left: 1px solid #29303a; min-height: 85vh; padding: 1.5em 1em; font-size: 1.04em; line-height: 1.5; display: flex; flex-direction: column; }
    #sidebar h3 { color: #ffd866; margin-top: 0; }
    #annotation-text { margin-top: 1.5em; white-space: pre-line; }
    @media (max-width: 950px) {
      #viewer-container { flex-direction: column; }
      #sidebar { width: 100vw; border-left: none; border-top: 1px solid #29303a; min-height: unset; }
      #canvas-holder { height: 50vh; }
    }
  </style>
</head>
<body>
  <div id="loader-bar">
    <label for="manifest-input" style="font-weight:bold;">IIIF Manifest URL:</label>
    <input id="manifest-input" type="text" placeholder="Paste IIIF Manifest URL here" />
    <button id="load-btn">Load Manifest</button>
    <select id="canvas-select" title="Choose a canvas" style="display:none;"></select>
    <button id="reload-btn" title="Reload current canvas" style="display:none;">Reload</button>
  </div>

  <div id="viewer-container">
    <div id="canvas-holder">
      <canvas id="iiif-canvas"></canvas>
      <svg id="overlay-svg"></svg>
    </div>
    <div id="sidebar">
      <h3>Annotation</h3>
      <div id="annotation-text">Load a manifest to begin.</div>
    </div>
  </div>

  <script>
    const manifestInput = document.getElementById('manifest-input');
    const loadBtn = document.getElementById('load-btn');
    const reloadBtn = document.getElementById('reload-btn');
    const canvasSelect = document.getElementById('canvas-select');

    const canvasElem = document.getElementById('iiif-canvas');
    const canvasHolder = document.getElementById('canvas-holder');
    const overlaySvg = document.getElementById('overlay-svg');
    const annotationText = document.getElementById('annotation-text');

    let manifest = null;
    let imageInfo = null;
    let annotationRegions = [];
    let overlayElems = [];

    loadBtn.onclick = async () => {
      const url = manifestInput.value.trim();
      if (!url) return alert('Paste a IIIF manifest URL!');
      try {
        annotationText.innerText = "Loading manifest...";
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Manifest fetch failed (${res.status})`);
        manifest = await res.json();
        populateCanvasSelect(manifest);
        canvasSelect.style.display = 'inline-block';
        reloadBtn.style.display = 'inline-block';
        await renderCanvasByIndex(0);
      } catch (e) {
        annotationText.innerText = "Failed to load manifest:\n" + (e.message || e);
      }
    };

    canvasSelect.onchange = async () => {
      const idx = parseInt(canvasSelect.value, 10) || 0;
      await renderCanvasByIndex(idx);
    };

    reloadBtn.onclick = async () => {
      const idx = parseInt(canvasSelect.value, 10) || 0;
      await renderCanvasByIndex(idx);
    };

    function populateCanvasSelect(man) {
      canvasSelect.innerHTML = "";
      const items = Array.isArray(man.items) ? man.items : [];
      items.forEach((c, i) => {
        const opt = document.createElement('option');
        opt.value = String(i);
        opt.textContent = labelToString(c.label) || `Canvas ${i+1}`;
        canvasSelect.appendChild(opt);
      });
      if (!items.length) {
        const opt = document.createElement('option');
        opt.value = "0";
        opt.textContent = "(no canvases)";
        canvasSelect.appendChild(opt);
      }
    }

    async function renderCanvasByIndex(index) {
      if (!manifest || !Array.isArray(manifest.items) || !manifest.items.length) {
        annotationText.innerText = "Manifest has no canvases.";
        return;
      }
      const canvas = manifest.items[index];
      if (!canvas) return;

      canvasSelect.value = String(index);

      clearViewer();
      annotationText.innerText = "Loading image...";

      imageInfo = { width: canvas.width, height: canvas.height, canvasId: canvas.id };

      // find painting image
      const paintingPage = canvas.items && canvas.items[0];
      const paintingAnno = paintingPage && paintingPage.items && paintingPage.items.find(a => getMotivations(a).includes("painting"));
      const imageUrl = paintingAnno && paintingAnno.body && (paintingAnno.body.id || paintingAnno.body['@id']);
      if (!imageUrl) {
        annotationText.innerText = "No painting annotation/image found for this canvas.";
        return;
      }

      await drawImageOnCanvas(imageUrl, imageInfo.width, imageInfo.height);

      // parse region annotations
      annotationRegions = [];
      if (Array.isArray(canvas.annotations)) {
        for (const page of canvas.annotations) {
          if (!page || !Array.isArray(page.items)) continue;
          for (const anno of page.items) {
            const motives = getMotivations(anno);
            if (!motives.some(m => ["supplementing","commenting","tagging"].includes(m))) continue;

            const shape = parseTargetToShape(anno.target, canvas.id);
            if (!shape) continue;

            const text = extractTextFromBody(anno.body);
            annotationRegions.push({ ...shape, text, annoId: anno.id || "" });
          }
        }
      }

      drawOverlays();
      annotationText.innerText = "Click a highlighted region to view its text here.";
      window.onresize = () => layoutOverlay();
    }

    // ---------- helpers ----------
    function labelToString(labelObj) {
      if (!labelObj || typeof labelObj !== 'object') return "";
      const langKeys = Object.keys(labelObj);
      if (!langKeys.length) return "";
      const first = labelObj[langKeys[0]];
      if (Array.isArray(first) && first.length) return first[0];
      return "";
    }

    function getMotivations(a) {
      if (!a || !a.motivation) return [];
      return Array.isArray(a.motivation) ? a.motivation : [a.motivation];
    }

    function extractTextFromBody(body) {
      if (!body) return "(no text)";
      const bodies = Array.isArray(body) ? body : [body];
      for (const b of bodies) {
        if (b && (b.type === "TextualBody" || b.type === "cnt:ContentAsText") && typeof b.value === "string" && b.value.length) {
          return b.value;
        }
      }
      for (const b of bodies) if (b && typeof b.value === "string" && b.value.length) return b.value;
      try { return JSON.stringify(bodies[0]); } catch { return "(no text)"; }
    }

    // Rect + SvgSelector parser
    function parseTargetToShape(target, expectedCanvasId) {
      if (!target) return null;

      // Compact "#xywh"
      if (typeof target === "string") {
        const m = /#xywh(?:=pixel)?:([0-9]+),([0-9]+),([0-9]+),([0-9]+)/.exec(target);
        if (m) return { kind: 'rect', coords: { x:+m[1], y:+m[2], w:+m[3], h:+m[4] } };
        return null;
      }

      if (typeof target === "object") {
        const sel = target.selector || null;

        if (sel && typeof sel === "object" && (sel.type === "FragmentSelector" || sel.type === "Fragment") && typeof sel.value === "string") {
          const m = /xywh(?:=pixel)?:([0-9]+),([0-9]+),([0-9]+),([0-9]+)/.exec(sel.value);
          if (m) return { kind: 'rect', coords: { x:+m[1], y:+m[2], w:+m[3], h:+m[4] } };
        }

        if (sel && typeof sel === "object" && sel.type === "SvgSelector" && typeof sel.value === "string") {
          try {
            const svgDoc = new DOMParser().parseFromString(sel.value, "image/svg+xml");

            // Optional rotate on group
            let rotateDeg = 0;
            const g = svgDoc.querySelector('g[transform^="rotate"]');
            if (g) {
              const rm = /rotate\(([-0-9.]+)\s+[0-9.]+\s+[0-9.]+\)/.exec(g.getAttribute('transform') || "");
              if (rm) rotateDeg = parseFloat(rm[1]) || 0;
            }

            const polygon = svgDoc.querySelector('polygon');
            if (polygon && polygon.hasAttribute('points')) {
              const pts = polygon.getAttribute('points').trim().split(/\s+/).map(p => p.split(',').map(Number));
              return { kind: 'polygon', coords: pts };
            }

            const polyline = svgDoc.querySelector('polyline');
            if (polyline && polyline.hasAttribute('points')) {
              const pts = polyline.getAttribute('points').trim().split(/\s+/).map(p => p.split(',').map(Number));
              return { kind: 'polyline', coords: pts };
            }

            const circle = svgDoc.querySelector('circle');
            if (circle && circle.hasAttribute('cx')) {
              return { kind: 'circle', coords: { cx: +circle.getAttribute('cx'), cy: +circle.getAttribute('cy'), r: +circle.getAttribute('r') } };
            }

            const ellipse = svgDoc.querySelector('ellipse');
            if (ellipse && ellipse.hasAttribute('cx')) {
              const cx = +ellipse.getAttribute('cx'), cy = +ellipse.getAttribute('cy');
              const rx = +ellipse.getAttribute('rx'), ry = +ellipse.getAttribute('ry');
              return { kind: 'ellipse', coords: { cx, cy, rx, ry, rotateDeg } };
            }

            return null;
          } catch {
            return null;
          }
        }

        const src = target.source || target.id || target['@id'] || "";
        if (typeof src === "string") {
          const m2 = /#xywh(?:=pixel)?:([0-9]+),([0-9]+),([0-9]+),([0-9]+)/.exec(src);
          if (m2) return { kind: 'rect', coords: { x:+m2[1], y:+m2[2], w:+m2[3], h:+m2[4] } };
        }
      }

      return null;
    }

    // Drawing & layout
    function drawImageOnCanvas(imgUrl, imgW, imgH) {
      return new Promise((resolve, reject) => {
        const img = new window.Image();
        img.crossOrigin = "anonymous";
        img.onload = function() {
          let maxW = canvasHolder.clientWidth - 4;
          let maxH = canvasHolder.clientHeight - 4;
          let scale = Math.min(maxW / imgW, maxH / imgH, 1);
          let dispW = Math.round(imgW * scale);
          let dispH = Math.round(imgH * scale);
          canvasElem.width = dispW;
          canvasElem.height = dispH;
          canvasElem.style.width = dispW + "px";
          canvasElem.style.height = dispH + "px";
          const ctx = canvasElem.getContext("2d");
          ctx.clearRect(0,0,dispW,dispH);
          ctx.drawImage(img, 0, 0, dispW, dispH);
          imageInfo.displayWidth = dispW;
          imageInfo.displayHeight = dispH;
          imageInfo.scale = scale;

          layoutOverlay();
          resolve();
        };
        img.onerror = reject;
        img.src = imgUrl;
      });
    }

    function layoutOverlay() {
      if (!imageInfo) return;
      const rect = canvasElem.getBoundingClientRect();
      const holderRect = canvasHolder.getBoundingClientRect();
      const left = rect.left - holderRect.left;
      const top = rect.top - holderRect.top;

      overlaySvg.style.left = left + "px";
      overlaySvg.style.top = top + "px";
      overlaySvg.setAttribute('width', imageInfo.displayWidth || 0);
      overlaySvg.setAttribute('height', imageInfo.displayHeight || 0);
      overlaySvg.setAttribute('viewBox', `0 0 ${imageInfo.displayWidth || 0} ${imageInfo.displayHeight || 0}`);

      drawOverlays();
    }

    function clearViewer() {
      overlayElems.forEach(el => el.remove());
      overlayElems = [];
      annotationRegions = [];
      annotationText.innerText = "";
      overlaySvg.innerHTML = "";
    }

    function drawOverlays() {
      overlaySvg.innerHTML = "";
      overlayElems = [];
      const scale = imageInfo.scale || 1;

      annotationRegions.forEach((region) => {
        let el = null;
        if (region.kind === 'rect') {
          const {x,y,w,h} = region.coords;
          el = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          el.setAttribute('x', x * scale);
          el.setAttribute('y', y * scale);
          el.setAttribute('width', w * scale);
          el.setAttribute('height', h * scale);
        } else if (region.kind === 'polygon' || region.kind === 'polyline') {
          const tag = region.kind;
          el = document.createElementNS("http://www.w3.org/2000/svg", tag);
          const pts = region.coords.map(([px,py]) => `${px*scale},${py*scale}`).join(' ');
          el.setAttribute('points', pts);
        } else if (region.kind === 'circle') {
          const {cx, cy, r} = region.coords;
          el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          el.setAttribute('cx', cx * scale);
          el.setAttribute('cy', cy * scale);
          el.setAttribute('r', r * scale);
        } else if (region.kind === 'ellipse') {
          const {cx, cy, rx, ry, rotateDeg} = region.coords;
          el = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
          el.setAttribute('cx', cx * scale);
          el.setAttribute('cy', cy * scale);
          el.setAttribute('rx', rx * scale);
          el.setAttribute('ry', ry * scale);
          if (rotateDeg && Math.abs(rotateDeg) > 0.0001) {
            el.setAttribute('transform', `rotate(${rotateDeg} ${cx*scale} ${cy*scale})`);
          }
        } else {
          return;
        }

        el.classList.add('shape');
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          overlayElems.forEach(o => o.classList.remove('active'));
          el.classList.add('active');
          annotationText.innerText = region.text || "(no text)";
        });

        overlaySvg.appendChild(el);
        overlayElems.push(el);
      });

      // click-away to clear
      canvasHolder.onclick = function(e) {
        if (e.target === canvasElem || e.target === canvasHolder || e.target === overlaySvg) {
          overlayElems.forEach(o => o.classList.remove('active'));
          annotationText.innerText = "Click a highlighted region to view its text here.";
        }
      };
    }
  </script>
</body>
</html>